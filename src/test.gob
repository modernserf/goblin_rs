# this is a comment

# integers
1 123 1_000

# floats
1.0 1.2345

# strings
"hello" "hello, \"world\"" "\\"

"
This is a multiline string.
It spans across multiple lines.
"

# identifiers
let foo := 1
let Foo := 2
let foo123 := 3
let foo_bar := 4
let __ := 5
let _foo bar_ := 6
let  _foo bar 123 \_ \\ baz_ := 7

(foo = 1){assert: "identifiers"}
(_foo_ = foo){assert: "quoted identifiers"}

# primitives
(1 + 1 = 2){assert: "addition"}
(8 - 10 = -2){assert: "subtraction"}
(1.5 + 0.5 = 2.0){assert: "floats"}
("hello," ++ " world" = "hello, world"){assert: "strings"}

# objects
let outer := 123
let target := [
  on {empty}
  on {constant} 1
  on {arg: arg1} arg1
  on {_pun_} pun
  on {ivar} outer
]

target{empty}
(target{constant} = 1){assert: "key handlers"}
(target{arg: 2} = 2){assert: "pair handlers"}
let pun := 3
(target{_pun_} = 3){assert: "pun args"}
(target{ivar} = 123){assert: "ivars"}

let target := [{: x} x + 1]
(target{: 3} = 4){assert: "object shorthand"}

let target := [
  on {foo}
    self{foo: 1}
  on {foo: value}
    value + 1
]
(target{foo} = 2){assert: "self"}

let x := 1
let y := 2
let target := [
    on {foo: x}
        let y := 3
        x + y
]
let res := target{foo: 10} + x + y
(res = 16){assert: "shadowing"}

let target := [
  on {foo}
    target{foo: 1}
  on {foo: value}
    value + 2
]
(target{foo} = 3){assert: "indirect self"}

let target := [
  on {foo: do f}
    f{: 2}
]
let res := target{foo: {: value} value + 1}
(res = 3){assert: "do block"}

# frames
let f := [x: 1 y: 2]
(f{x} = 1){assert: "frame get"}
let g := f{y: 3}
(g{y} = 3){assert: "frame set"}
let h := f{->x: [+: 2]}
(h{x} = 3){assert: "frame update"}

([x]{: f} = 1){assert: "frame key match"}

let obj := [
  on {x: x y: y}
    x + y
]
let f := [x: 1 y: 2]
(f{: obj} = 3){assert: "frame pair match"}
let x := 1
let y := 2
let f := [_x_ _y_]
(f{x} = 1){assert: "frame pun args"}

# vars
var x := 1
(x = 1){assert: "vars"}
set x := 2
(x = 2){assert: "set"}

let do_block := [
  on {: do f}
    f{}
]
var x := 1
do_block{: on {}
  set x := 3
}
(x = 3){assert: "set in do block"}

var f := [x: 1 y: 2]
set f{y: 3}
(f{y} = 3){assert: "set in place"}

var a := [b: [c: [d: 4]]]
set a{->b:[->c:[->d:[+: 1]]]}
(a{b}{c}{d} = 5){assert: "deep set in place"}

let target := [
  on {inc: var value}
    set value{+: 1}
]
var x := 4
target{inc: var x}
(x = 5){assert: "var args"}

let a := (
  let x := 1
  let y := 2
  x + y
)
(a = 3){assert: "paren scopes"}

# conditionals
let res := (1 = 1){:
  on {true} "true"
  on {false} "false"
}
(res = "true"){assert: "match boolean"}

let x := 2
let res := if x = 1 then
  10
else if x = 2 then
  20
else
  30
end
(res = 20){assert: "if expression"}
